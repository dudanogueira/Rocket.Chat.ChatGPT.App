{"version":3,"sources":["../src/chatgpt-api.ts","../src/fetch.ts","../src/fetch-sse.ts","../src/utils.ts"],"sourcesContent":["import ExpiryMap from 'expiry-map'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport * as types from './types'\nimport { fetch } from './fetch'\nimport { fetchSSE } from './fetch-sse'\nimport { markdownToText } from './utils'\n\nconst KEY_ACCESS_TOKEN = 'accessToken'\nconst USER_AGENT =\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36'\n\nexport class ChatGPTAPI {\n  protected _sessionToken: string\n  protected _markdown: boolean\n  protected _apiBaseUrl: string\n  protected _backendApiBaseUrl: string\n  protected _userAgent: string\n\n  // stores access tokens for up to 10 seconds before needing to refresh\n  protected _accessTokenCache = new ExpiryMap<string, string>(10 * 1000)\n\n  /**\n   * Creates a new client wrapper around the unofficial ChatGPT REST API.\n   *\n   * @param opts.sessionToken = **Required** OpenAI session token which can be found in a valid session's cookies (see readme for instructions)\n   * @param apiBaseUrl - Optional override; the base URL for ChatGPT webapp's API (`/api`)\n   * @param backendApiBaseUrl - Optional override; the base URL for the ChatGPT backend API (`/backend-api`)\n   * @param userAgent - Optional override; the `user-agent` header to use with ChatGPT requests\n   */\n  constructor(opts: {\n    sessionToken: string\n\n    /** @defaultValue `true` **/\n    markdown?: boolean\n\n    /** @defaultValue `'https://chat.openai.com/api'` **/\n    apiBaseUrl?: string\n\n    /** @defaultValue `'https://chat.openai.com/backend-api'` **/\n    backendApiBaseUrl?: string\n\n    /** @defaultValue `'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36'` **/\n    userAgent?: string\n  }) {\n    const {\n      sessionToken,\n      markdown = true,\n      apiBaseUrl = 'https://chat.openai.com/api',\n      backendApiBaseUrl = 'https://chat.openai.com/backend-api',\n      userAgent = USER_AGENT\n    } = opts\n\n    this._sessionToken = sessionToken\n    this._markdown = !!markdown\n    this._apiBaseUrl = apiBaseUrl\n    this._backendApiBaseUrl = backendApiBaseUrl\n    this._userAgent = userAgent\n\n    if (!this._sessionToken) {\n      throw new Error('ChatGPT invalid session token')\n    }\n  }\n\n  async getIsAuthenticated() {\n    try {\n      void (await this.refreshAccessToken())\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  async ensureAuth() {\n    return await this.refreshAccessToken()\n  }\n\n  /**\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\n   * the response.\n   *\n   * @param message - The plaintext message to send.\n   * @param opts.conversationId - Optional ID of the previous message in a conversation\n   * @param opts.onProgress - Optional listener which will be called every time the partial response is updated\n   */\n  async sendMessage(\n    message: string,\n    opts: {\n      conversationId?: string\n      onProgress?: (partialResponse: string) => void\n    } = {}\n  ): Promise<string> {\n    const { conversationId = uuidv4(), onProgress } = opts\n\n    const accessToken = await this.refreshAccessToken()\n\n    const body: types.ConversationJSONBody = {\n      action: 'next',\n      messages: [\n        {\n          id: uuidv4(),\n          role: 'user',\n          content: {\n            content_type: 'text',\n            parts: [message]\n          }\n        }\n      ],\n      model: 'text-davinci-002-render',\n      parent_message_id: conversationId\n    }\n\n    const url = `${this._backendApiBaseUrl}/conversation`\n\n    // TODO: What's the best way to differentiate btwn wanting just the response text\n    // versus wanting the full response message, so you can extract the ID and other\n    // metadata?\n    // let fullResponse: types.Message = null\n    let response = ''\n\n    return new Promise((resolve, reject) => {\n      fetchSSE(url, {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n          'user-agent': this._userAgent\n        },\n        body: JSON.stringify(body),\n        onMessage: (data: string) => {\n          if (data === '[DONE]') {\n            return resolve(response)\n          }\n\n          try {\n            const parsedData: types.ConversationResponseEvent = JSON.parse(data)\n            const message = parsedData.message\n            // console.log('event', JSON.stringify(parsedData, null, 2))\n\n            if (message) {\n              let text = message?.content?.parts?.[0]\n\n              if (text) {\n                if (!this._markdown) {\n                  text = markdownToText(text)\n                }\n\n                response = text\n                // fullResponse = message\n\n                if (onProgress) {\n                  onProgress(text)\n                }\n              }\n            }\n          } catch (err) {\n            console.warn('fetchSSE onMessage unexpected error', err)\n            reject(err)\n          }\n        }\n      }).catch(reject)\n    })\n  }\n\n  async refreshAccessToken(): Promise<string> {\n    const cachedAccessToken = this._accessTokenCache.get(KEY_ACCESS_TOKEN)\n    if (cachedAccessToken) {\n      return cachedAccessToken\n    }\n\n    try {\n      const res = await fetch('https://chat.openai.com/api/auth/session', {\n        headers: {\n          cookie: `__Secure-next-auth.session-token=${this._sessionToken}`,\n          'user-agent': this._userAgent\n        }\n      }).then((r) => r.json() as any as types.SessionResult)\n\n      const accessToken = res?.accessToken\n\n      if (!accessToken) {\n        throw new Error('Unauthorized')\n      }\n\n      const error = res?.error\n      if (error) {\n        if (error === 'RefreshAccessTokenError') {\n          throw new Error('session token has expired')\n        } else {\n          throw new Error(error)\n        }\n      }\n\n      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken)\n      return accessToken\n    } catch (err: any) {\n      throw new Error(`ChatGPT failed to refresh auth token. ${err.toString()}`)\n    }\n  }\n}\n","import fetch from 'node-fetch'\n\nexport { fetch }\n","import { createParser } from 'eventsource-parser'\n\nimport { fetch } from './fetch'\n\n// import { streamAsyncIterable } from './stream-async-iterable'\n\nexport async function fetchSSE(\n  url: string,\n  options: Parameters<typeof fetch>[1] & { onMessage: (data: string) => void }\n) {\n  const { onMessage, ...fetchOptions } = options\n  const resp = await fetch(url, fetchOptions)\n  const parser = createParser((event) => {\n    if (event.type === 'event') {\n      onMessage(event.data)\n    }\n  })\n\n  resp.body.on('readable', () => {\n    let chunk: string | Buffer\n    while (null !== (chunk = resp.body.read())) {\n      parser.feed(chunk.toString())\n    }\n  })\n\n  // TODO: add support for web-compatible `fetch`\n  // for await (const chunk of streamAsyncIterable(resp.body)) {\n  //   const str = new TextDecoder().decode(chunk)\n  //   parser.feed(str)\n  // }\n}\n","import { remark } from 'remark'\nimport stripMarkdown from 'strip-markdown'\n\nexport function markdownToText(markdown?: string): string {\n  return remark()\n    .use(stripMarkdown)\n    .processSync(markdown ?? '')\n    .toString()\n}\n"],"mappings":"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","names":["ExpiryMap","uuidv4","fetch","createParser","fetchSSE","url","options","onMessage","fetchOptions","resp","fetch","parser","createParser","event","chunk","remark","stripMarkdown","markdownToText","markdown","KEY_ACCESS_TOKEN","USER_AGENT","ChatGPTAPI","opts","ExpiryMap","sessionToken","markdown","apiBaseUrl","backendApiBaseUrl","userAgent","message","conversationId","uuidv4","onProgress","accessToken","body","url","response","resolve","reject","fetchSSE","data","_a","_b","text","markdownToText","err","cachedAccessToken","res","fetch","r","error"]}